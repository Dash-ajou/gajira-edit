{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;;;;;;;;AAQA","sources":[".././action.js",".././common/net/Jira.js",".././common/net/client.js","../../../../../../../opt/homebrew/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"fs\"","../external node-commonjs \"url\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":["const _ = require('lodash')\nconst Jira = require('./common/net/Jira')\n\nmodule.exports = class {\n  constructor ({ githubEvent, argv, config }) {\n    this.Jira = new Jira({\n      baseUrl: config.baseUrl,\n      token: config.token,\n      email: config.email,\n    })\n\n    this.config = config\n    this.argv = argv\n    this.githubEvent = githubEvent\n  }\n\n  async execute () {\n    const { argv } = this\n\n    const projectKey = argv.project\n    const issueId = argv.issue\n\n    const issue = await this.Jira.getIssue(issueId)\n    if (!issue) {\n      console.log(`Issue Not Found`);\n      return\n    }\n\n    let providedFields = [{\n      key: 'project',\n      value: {\n        key: projectKey,\n      },\n    }, {\n      key: 'summary',\n      value: argv.summary,\n    }]\n\n    if (argv.description) {\n      providedFields.push({\n        key: 'description',\n        value: argv.description,\n      })\n    }\n\n    if (argv.fields) {\n      providedFields = [...providedFields, ...this.transformFields(argv.fields)]\n    }\n\n    const payload = providedFields.reduce((acc, field) => {\n      acc.fields[field.key] = field.value\n\n      return acc\n    }, {\n      fields: {},\n    })\n\n    await this.Jira.updateIssue(issueId, payload);\n\n    // console.log(`transitionedIssue:${JSON.stringify(transitionedIssue, null, 4)}`)\n    console.log(`Update ${issueId} complete.`)\n    console.log(`Link to issue: ${this.config.baseUrl}/browse/${issueId}`)\n\n    return {}\n  }\n}\n","const { get } = require('lodash')\n\nconst serviceName = 'jira'\nconst { format } = require('url')\nconst client = require('./client')(serviceName)\n\nclass Jira {\n  constructor ({ baseUrl, token, email }) {\n    this.baseUrl = baseUrl\n    this.token = token\n    this.email = email\n  }\n\n  async updateIssue (body) {\n    return this.fetch('updateIssue',\n      { pathname: '/rest/api/2/issue' },\n      { method: 'PUT', body })\n  }\n\n  async getIssue (issueId, query = {}) {\n    const { fields = [], expand = [] } = query\n\n    try {\n      return this.fetch('getIssue', {\n        pathname: `/rest/api/2/issue/${issueId}`,\n        query: {\n          fields: fields.join(','),\n          expand: expand.join(','),\n        },\n      })\n    } catch (error) {\n      if (get(error, 'res.status') === 404) {\n        return\n      }\n\n      throw error\n    }\n  }\n\n  async getIssueTransitions (issueId) {\n    return this.fetch('getIssueTransitions', {\n      pathname: `/rest/api/2/issue/${issueId}/transitions`,\n    }, {\n      method: 'GET',\n    })\n  }\n\n  async transitionIssue (issueId, data) {\n    return this.fetch('transitionIssue', {\n      pathname: `/rest/api/2/issue/${issueId}/transitions`,\n    }, {\n      method: 'POST',\n      body: data,\n    })\n  }\n\n  async fetch (apiMethodName,\n    { host, pathname, query },\n    { method, body, headers = {} } = {}) {\n    const url = format({\n      host: host || this.baseUrl,\n      pathname,\n      query,\n    })\n\n    if (!method) {\n      method = 'GET'\n    }\n\n    if (headers['Content-Type'] === undefined) {\n      headers['Content-Type'] = 'application/json'\n    }\n\n    if (headers.Authorization === undefined) {\n      headers.Authorization = `Basic ${Buffer.from(`${this.email}:${this.token}`).toString('base64')}`\n    }\n\n    // strong check for undefined\n    // cause body variable can be 'false' boolean value\n    if (body && headers['Content-Type'] === 'application/json') {\n      body = JSON.stringify(body)\n    }\n\n    const state = {\n      req: {\n        method,\n        headers,\n        body,\n        url,\n      },\n    }\n\n    try {\n      await client(state, `${serviceName}:${apiMethodName}`)\n    } catch (error) {\n      const fields = {\n        originError: error,\n        source: 'jira',\n      }\n\n      delete state.req.headers\n\n      throw Object.assign(\n        new Error('Jira API error'),\n        state,\n        fields\n      )\n    }\n\n    return state.res.body\n  }\n}\n\nmodule.exports = Jira\n","const fetch = require('node-fetch')\n// const moment = require('moment')\n\nmodule.exports = serviceName => async (state, apiMethod = 'unknown') => {\n  // const startTime = moment.now()\n\n  const response = await fetch(state.req.url, state.req)\n\n  state.res = {\n    headers: response.headers.raw(),\n    status: response.status,\n  }\n\n  // const totalTime = moment.now() - startTime\n  // const tags = {\n  //   api_method: apiMethod,\n  //   method: state.req.method || 'GET',\n  //   response_code: response.status,\n  //   service: serviceName,\n  // }\n\n  state.res.body = await response.text()\n\n  const isJSON = (response.headers.get('content-type') || '').includes('application/json')\n\n  if (isJSON && state.res.body) {\n    state.res.body = JSON.parse(state.res.body)\n  }\n\n  if (!response.ok) {\n    throw new Error(response.statusText)\n  }\n\n  return state\n}\n",null,"module.exports = require(\"fs\");","module.exports = require(\"url\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";"],"names":[],"sourceRoot":""}